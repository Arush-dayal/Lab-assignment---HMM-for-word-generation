package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/testcontainers/testcontainers-go"
	. "github.com/wiremock/wiremock-testcontainers-go"
	"golang.org/x/oauth2/clientcredentials"
)

// BankAPIClient-onsumer of bank api
type BankAPIClient struct {
	httpClient *http.Client
	baseURL    string
}

func NewBankAPIClient(httpClient *http.Client, baseURL string) *BankAPIClient {
	return &BankAPIClient{
		httpClient: httpClient,
		baseURL:    baseURL,
	}
}

func (c *BankAPIClient) GetAccounts(ctx context.Context) (map[string]interface{}, error) {
	accountsURL := fmt.Sprintf("%s/api/accounts", c.baseURL)
	log.Printf("Client: Requesting data from protected endpoint: %s", accountsURL)

	response, err := c.httpClient.Get(accountsURL)
	if err != nil {
		return nil, fmt.Errorf("failed to get accounts: %w", err)
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("bank API returned an error. Status: %s", response.Status)
	}

	var result map[string]interface{}
	if err := json.NewDecoder(response.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to parse response JSON: %w", err)
	}
	return result, nil
}

// Mapping in a seperate json file.
func TestBankAPIConsumer_SuccessfulFetch(t *testing.T) {
	ctx := context.Background()

	wiremockMapping := `
{
	"mappings": [
		{
		"request": { "method": "POST", "urlPath": "/oauth/token" },
		"response": {
			"status": 200,
			"headers": { "Content-Type": "application/json" },
			"jsonBody": { "access_token": "test-token-123", "token_type": "Bearer", "expires_in": 3600 }
		}
		},
		{
		"request": {
			"method": "GET",
			"urlPath": "/api/accounts",
			"headers": { "Authorization": { "equalTo": "Bearer test-token-123" } }
		},
		"response": {
			"status": 200,
			"headers": { "Content-Type": "application/json" },
			"jsonBody": { "accounts": [ { "id": "TEST-ACC-001", "source": "Testcontainers" } ] }
		}
		}
	]
`
}
func TestWireMock(t *testing.T) {
	//Creating container and initializations
	ctx := context.Background()
	container, err := RunContainer(ctx, testcontainers.WithImage("wiremock/wiremock:latest"), WithMappingFile("hello", "testdata/hello-world.json"))

	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		log.Println("Terminating WireMock container.")
		if err := container.Terminate(context.Background()); err != nil {
			t.Fatalf("Failed to terminate container: %s", err)
		}
	})

	baseURL, err := container
	if err != nil {
		t.Fatal(err)
	}

	conf := &clientcredentials.Config{
		ClientID:     "test-client-id",
		ClientSecret: "test-client-secret",
		TokenURL:     fmt.Sprintf("%s/oauth/token", wiremockURI),
	}
	oauthHttpClient := conf.Client(ctx)

	// 5. Create an instance of our application's client, configured for the test.
	bankClient := NewBankAPIClient(oauthHttpClient, wiremockURL)

	accounts, err := bankClient.GetAccounts(ctx)
	require.NoError(t, err)
	assert.NotNil(t, accounts)

	accountData, ok := accounts["accounts"].([]interface{})
	require.True(t, ok)
	require.Len(t, accountData, 1)

	firstAccount, ok := accountData[0].(map[string]interface{})
	require.True(t, ok)
	assert.Equal(t, "TEST-ACC-001", firstAccount["id"])
	assert.Equal(t, "Testcontainers", firstAccount["source"])

	log.Println("Test finished successfully!")

}
